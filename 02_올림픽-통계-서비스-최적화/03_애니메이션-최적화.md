# 03. 애니메이션 최적화

## 📌 3.1 문제의 애니메이션 찾기

앞서 말했듯, 이 서비스에 **애니메이션**이 들어간 곳은 **설문 결과 영역**이다.  
설문 항목을 클릭하면 해당 응답에 대해 필터링되고 막대 그래프의 배경 색과 막대의 가로 길이가 변하는 것이다.

애니메이션을 계속 보다 보면, 가로 막대가 늘어날 때 끊기는 듯한 느낌이 있다.

만약 컴퓨터의 성능이 좋아서 잘 느껴지지 않는다면, 개발자 도구의 **Performance** 패널의 CPU 설정을 `6x slowdown`으로 설정하면 된다.  
이러면 애니메이션이 끊기는 현상을 더 잘 확인할 수 있다.

<img width="745" alt="Screenshot 2023-05-16 at 22 29 25" src="https://github.com/whateveriiwant/whateveriiwant/assets/80333011/1e244b2b-51a7-4316-939c-8385878e3274">

이러한 끊김 현상을 **쟁크(jank)**라고 한다.

> ### 💻 성능 좋은 PC의 경우..
>
> 성능이 좋은 PC나 최신 브라우저는 최적화가 잘 되어 있어 CPU slowdown을 6x로 설정 해도 쟁크 현상이 발생하지 않을 수 있다.
>
> 제대로 확인하기 어렵다면 브라우저를 컴퓨터가 느려질 정도로 많이 띄워 두는 식으로 CPU를 바쁘게 만들어 테스트를 할 수도 있다.

```javascript
const BarGraph = styled.div`
    ...
    width: ${({ width }) => width}%;
    ...
`;
```

막대 그래프의 `width` 속성 변경 코드이다.  
코드에서 알 수 있듯이 이 애니메이션을 일으키는 속성은 **transition**이 적용된 `width` 속성 밖에 없다.

여기서 **쟁크** 현상이 왜 발생하는지 답하려면 다음 개념을 이해해야 한다.

- 브라우저에서 애니메이션이 어떻게 동작하는가
- 브라우저는 어떤 과정을 거쳐 화면을 그리는가

## 📌 3.2 애니메이션의 원리

애니메이션의 원리는 여러 장의 이미지를 빠르게 전환하여 우리 눈에 잔상을 남기고, 그로 인해 연속된 이미지가 움직이는 것처럼 느껴지게 하는 것이다.

<tr>
    <td>
        <img src="https://github.com/whateveriiwant/whateveriiwant/assets/80333011/59a67275-cee2-4940-9d02-2e28eff4d476" width="40%" />
    </td>
    <td>
        <img src="https://github.com/whateveriiwant/whateveriiwant/assets/80333011/108bdeb2-2426-463e-8606-955e3bd8a746" width="40%" />
    </td>
</tr>

왼쪽의 애니메이션 프레임에서 한 프레임이 삭제된다면, 이 일련의 과정이 어색하게 끊기는 느낌이 들 것이다.

일반적으로 사용하는 **디스플레이**의 주사율은 **60Hz**이다. 즉, 1초에 60장의 정지된 화면을 빠르게 보여준다.

따라서 **브라우저**도 이에 맞춰 최대 **60FPS**(Frames Per Second)로 1초에 60장의 화면을 새로 그린다.

### 📎 이 서비스에서는..

위에 작성한 원리를 이용하면 올림픽 통계 서비스의 막대 그래프 애니메이션에서 **쟁크** 현상이 발생한 이유도 브라우저가 정상적으로 60FPS로 화면을 그리지 못했기 때문이라고 유추해 볼 수 있다.

예를 들어, CPU가 다른 일을 하느라 바빠서 초당 60장의 화면을 그리지 못하고 그보다 적은 화면을 그려 애니메이션이 끊기는 느낌을 준 것이다.

그렇다면 브라우저는 왜 초당 60프레임을 제대로 그리지 못하는 것인가?

이 질문에 대한 답변은 브라우저가 화면을 그리는 과정을 앎으로써 가능하다.

## 📌 3.3 브라우저 렌더링 과정

브라우저의 **렌더링** 과정은 다음 일련의 과정으로 이루어진다.

> 1. DOM + CSSOM
> 2. 렌더 트리
> 3. 레이아웃
> 4. 페인트
> 5. 컴포지트

브라우저는 기본적으로 위와 같은 과정을 거쳐서 화면을 그린다.  
이러한 과정을 **주요 렌더링 경로(Critical Rendering Path)** 또는 **픽셀 파이프라인(Pixel Pipeline)** 이라고 한다.

### 1️⃣ DOM + CSSOM

가장 처음에는 HTML 파일과 CSS 등 **화면을 그리는 데 필요한 리소스**를 다운로드한다.  
다운로드한 HTML은 브라우저가 이해할 수 있는 형태로 변한하는 **파싱(parsing)** 과정을 거친다.

그렇게 해서 요소 간의 관계가 **트리(tree)** 구조로 표현되어 있는 **DOM(Document Object Model)** 을 만든다.

마찬가지로 CSS도 브라우저가 이해할 수 있는 형태로 변환된다.  
변환 결과, **CSSOM(Css Object Model)** 이라는 **트리** 구조가 생성된다.

CSSOM은 각 요소가 어떤 스타일을 포함하고 있는지에 대한 정보를 포함한다.

<tr>
    <td>
       <img width="397" alt="image" src="https://github.com/whateveriiwant/whateveriiwant/assets/80333011/90abab5b-e6d4-4ff5-a6de-f8d02ea095eb">
    </td>
    <td>
        <img width="363" alt="image" src="https://github.com/whateveriiwant/whateveriiwant/assets/80333011/f4e90a77-ae82-442b-bfcb-ec82ba4f572d">
    </td>
</tr>

### 2️⃣ 렌더 트리

**렌더 트리(render tree)** 는 **DOM과 CSSOM의 결합**으로 생성된다.

이 렌더 트리는 화면에 표시되는 각 요소의 레이아웃을 계산하는 데 사용된다.  
달리 말하면, `display: none` 으로 설정되어 화면에 표시되지 않는 요소는 렌더 트리에 포함되지 않는다.

> `display: none` 은 렌더 트리에 포함되지 않는다.  
> 그러나 `opacity: 0` 이나 `visibility: hidden` 인 요소는 렌더 트리에 **포함**된다.  
> 이러한 속성은 사용자 눈에는 보이지 않지만 요소 자체가 없어진 것은 아니기 때문이다.

<img width="770" alt="image" src="https://github.com/whateveriiwant/whateveriiwant/assets/80333011/c6c20a3a-e359-4bea-86bb-0d092d6639d9">

### 3️⃣ 레이아웃

렌더 트리가 완성되면, **레이아웃(layout)** 단계로 넘어간다.  
레이아웃 단계에서는 **화면 구성 요소**의 **위치**나 **크기**를 계산하고, 해당 위치에 **요소를 배치**하는 작업을 한다.

말 그대로 화면의 레이아웃을 잡는 것이다.

다음 사진은 레이아웃 작업의 예시이다.

<img width="431" alt="image" src="https://github.com/whateveriiwant/whateveriiwant/assets/80333011/974619cc-ae5c-4e1c-809c-3d4e4441c022">

### 4️⃣ 페인트

**페인트(paint)** 단계에서는 화면에 배치된 요소에 **색**을 채워 넣는 작업을 한다.

예를 들어 배경 색을 채워 넣거나 글자 색을 결정하는 것이다.

이 때 **브라우저**는 효율적인 **페인트** 과정을 위해 **구성 요소**를 여러 개의 **레이어(layer)**로 나눠서 작업하기도 한다.

<img width="494" alt="image" src="https://github.com/whateveriiwant/whateveriiwant/assets/80333011/26fe9082-38fb-4abd-b9e4-868bf2e76fec">

### 5️⃣ 컴포지트

**컴포지트(composite)** 단게는 **각 레이어를 합성**하는 작업을 한다.

**페인트** 단계에서 설명한 것처럼 브라우저는 화면을 그릴 때 여러 개의 **레이어**로 화면을 쪼개서 그린다.  
그런 다음 마지막에 그 **레이어**를 **하나로 합성**하는데, 그 단계가 바로 **컴포지트** 단계이다.

이 과정은 브라우저에서 직접 확인해 볼 수 있다.  
<img width="652" alt="image" src="https://github.com/whateveriiwant/whateveriiwant/assets/80333011/52f1de9e-a379-4b03-98d6-2a618000c901">

개발자 도구의 **Performance** 패널에서 **메인 스레드**의 작업을 살펴보면 위 사진과 같이 작업 이름이 **Parse HTML, Layout, Paint** 라고 되어 있는 것을 볼 수 있다.

이 작업이 지금까지 살펴본 **브라우저 렌더링 과정**이다.

<img width="485" alt="Screenshot 2023-05-18 at 11 35 54" src="https://github.com/whateveriiwant/whateveriiwant/assets/80333011/23573cd6-05b8-4459-96ec-7e569385a806">

차트를 보면 노란 점선을 확인할 수 있다. 바로 브라우저가 **화면을 갱신**하는 주기이다.

즉, 화면을 그리는 시점이 바로 노란 점선으로 된 시점이다.

> 위 노란 점선은 렌더링 시점의 이해를 돕기 위해 임의로 그린 것으로, 실제 개발자 도구에서는 표시되지 않으니 유의 할 것!

### 📎 리플로우

화면이 전부 그려진 후, 설문 결과에서의 애니메이션처럼 일부 요소의 스타일을 변경, 추가, 제거하는 경우가 있을 것이다.  
이런 경우 주요 렌더링 경로에서 거친 과정을 다시 한 번 실행하면서 새로운 화면을 그린다.

이것을 **리플로우(Reflow)** 또는 **리페인트(Repaint)** 라고 한다.

## 📌 3.4 리플로우와 리페인트

### 📎 리플로우

한 가지 예를 들어 보겠다.  
처음 화면이 모두 그려진 후, 자바스크립트로 인해 화면 내 어떤 요소의 너비와 높이가 변경되었다고 가정한다. 그러면 브라우저는 해당 요소의 가로와 세로를 다시 계산해 **변경된 사이즈**로 화면을 새로 그릴 것이다.

앞서 살펴본 주요 렌더링 경로에 대입해 보면, 먼저 요소의 스타일이 변했으니 **CSSOM**을 새로 만들어야 한다.  
그러고 나서 변경된 **CSSOM**을 이용하여 새로운 렌더 트리를 만든다.  
그리고 요소의 가로와 세로를 변경했으니, 레이아웃 단계에서 당연히 요소의 크기와 위치를 다시 고려해야 한다.  
그 다음 변경된 화면 구성에 알맞게 색을 칠하고(**페인트**) 분할된 레이어를 하나로 합성(**컴포지트**) 할 것이다.

이것을 **리플로우**라고 한다.

리플로우는 주요 렌더링 경로의 모든 단계를 **모두 재실행**한다.  
따라서 브라우저 **리소스**를 많이 사용한다.

### 📎 리페인트

또 다른 경우를 예로 들어 보겠다.  
이번에는 한 요소의 가로, 세로와 같은 레이아웃 관련 속성이 아닌 글자 색(color)이나 배경 색(background-color) 등, **색상 관련 속성**이 변경되었다고 가정해 보겠다.

처음에는 스타일 속성이 변경되었기 때문에 **CSSOM**이 **새로 생성**될 것이고, **렌더 트리**도 새로 만들어질 것이다.  
하지만 레이아웃 단계는 **실행되지 않는다**.  
왜냐하면 지금 변경된 내용은 오직 색상에 관련된 내용이기 때문이다.

그렇게 레이아웃 단계를 건너뛴 뒤, **페인트**단계, **컴포지트** 단계를 거친다.

이것을 **리페인트**라고 한다.

**리페인트** 작업은 레이아웃 단계를 건너뛰기 때문에 **리플로우**보다는 조금 더 빠를 것이다.  
그러나 리페인트 역시 거의 모든 렌더링 단계를 거치기 때문에 리소스를 꽤 잡아먹는다.

> ### 📎 리플로우와 리페인트를 발생시키는 속성
>
> - 리플로우: position, display, width, float, height, font-family, top, left, font-size, font-weight, line-height, min-height, margin, padding, border, ...
>
> - 리페인트: background, background-image, background-position, border-radius, border-style, box-shadow, color, line-style, outline, ...

정리하자면, 요소의 상태 변화가 일어나면 **리플로우**나 **리페인트** 과정을 거친다.  
이러한 과정은 브라우저의 리소스를 많이 잡아먹어 결국 화면을 새로 그리는 것이 **느려지게** 된다.

**리플로우**와 **리페인트**를 피하는 방법이 있다.  
바로 `transform`, `opacity` 와 같은 속성을 사용하는 것이다.  
이런 속성을 사용하면 해당 요소를 별도의 **레이어**로 분리하고 작업을 **GPU에 위임**하여 처리한다.

이것을 **하드웨어 가속**이라고 한다.

## 📌 3.5 하드웨어 가속(GPU 가속)

> CPU에서 처리해야 할 작업을 GPU에 위임하여 더욱 효율적으로 처리하는 방법이다.
>
> GPU는 그래픽 작업을 처리하기 위해 만들어진 것이므로 화면을 그릴 때 활용하면 굉장히 빠르다.

특정 요소에 하드웨어 가속을 사용하려면 요소를 별도의 레이어로 분리하여 GPU로 보내야한다.  
이는 `transform`, `opacity` 속성이 이 역할을 한다.  
**분리된 레이어**는 GPU에 의해 처리되어 **레이아웃, 페인트 단계 없이** 화면상의 요소의 스타일을 변경할 수 있다.

따라서 **리플로우**와 **리페인트**를 일으키는 `width`, `height`, `color` 등의 속성이 아닌 `transform` 또는 `opacity` 속성을 이용한 애니메이션 성능이 더 좋을 수밖에 없다.

> ### 🚨 주의
>
> `transform: translate()` 는 처음부터 레이어를 분리하지 않고 **변화가 일어나는 순간 레이어를 분리**한다.  
> 반면 `transform: translate3d()` 또는 `scale3d()` 와 같은 3d 속성들, 또는 `will-change` 속성은 **처음부터 레이어를 분리**해 두기 때문에 변화에 더욱 빠르게 대처할 수 있다.  
> 물론 레이어가 너무 많아지면 그만큼 메모리를 많이 사용하기 때문에 주의해야 한다.

다시 그래프 애니메이션을 확인해 보겠다.  
막대 그래프는 `width` 를 변경하여 애니메이션 효과를 줬다.  
이렇게 하면 `width` 가 변할 때 마다 **리플로우**가 발생하고, 브라우저가 아주 짧은 순간마다 화면을 갱신해야 한다.  
따라서 모든 단계를 제시간에 처리하지 못하는 **쟁크** 현상이 발생하게 된다.

이 과정은 개발자 도구의 **Performance** 패널을 통해 살펴볼 수 있다.  
앞서 했던 것 처럼 **Performance** 패널을 열고 CPU를 `6x slowdown` 으로 설정한다.

이번에는 새로고침 버튼이 아닌 왼쪽 상단의 기록 버튼을 누른 후, 막대 그래프를 클릭해 애니메이션을 재생한다.  
그런 다음 다시 기록 버튼을 눌러 기록을 마치면 애니메이션이 발생한 순간의 브라우저 작업이 기록 된다.

<img width="270" alt="image" src="https://github.com/whateveriiwant/whateveriiwant/assets/80333011/5a866fa9-6d76-410d-9b3d-bf9336ac2f65">

> ### 📚 여담
>
> 참고로 성능 분석을 실시할 때는 시크릿 모드에서 수행하는 것이 좋다.  
> 어떠한 기본 캐시 없이 말끔한 상태에서 작업을 진행할 수 있기 때문이다!  
> 성능 기록은 약 2~3초 정도만 진행하도록 한다.

<img width="747" alt="Screenshot 2023-05-18 at 12 21 26" src="https://github.com/whateveriiwant/whateveriiwant/assets/80333011/c0366f47-13fc-4082-9333-8283da6d775e">

기록된 내용 중 애니메이션이 일어나는 구간을 확대해보면 위 사진과 같이 레이아웃, 페인트, 컴포지트가 일어나는 것을 볼 수 있다.  
바로 `width` 의 변경으로 인해 **리플로우**가 발생한 모습이다.

그런데 여기서 한 가지 특이한 점이 있다.  
빨간 네모 안을 보면 리플로우 작업이 브라우저가 하면을 갱신하는 시점인 노란 점선을 넘어가고 있다.

즉, 화면을 1/60초 안에 그려서 보여 줘야 하는데 리플로우가 발생하여 모든 단계를 다시 밟느라 필요한 화면을 제때 그려내지 못한 것이다.

화면이 개신되기 전에 모든 작업을 마치려면 어떤 방법을 쓰는가에 대한 답변은 다음과 같다.  
리플로우나 리페인트가 일어나는 속성이 아닌 GPU를 활용하여 레이아웃 단계와 페인트 단계를 건너뛸 수 있는 `transform` 같은 속성을 사용하는 것이다.

## 📌 3.6 애니메이션 최적화

문제를 해결하기 위해 `width` 로 되어있는 애니메이션을 `transform` 으로 변경하여 최적화한다.

`transform` 속성에는 다양한 값이 들어갈 수 있다.  
**위치를 이동**시키는 `translate`, **크기를 변경**하는 `scale`, **요소를 회전**시키는 `rotate`가 대표적이다.

여기서는 `scale` 을 사용해 구현한다.
미리 막대의 너비를 100%로 채워 두고 `scale`을 이용해 비율에 따라 줄이는 방식이다. 코드로 보면 다음과 같다.

### 🌧️ 변경 전

```javascript
const BarGraph = styled.div`
    ...
    width: ${({ width }) => width}%;
    transition: width 1.5s ease;
    ...
`;
```

### 🌤️ 변경 후

```javascript
const BarGraph = styled.div`
    ...
    width: 100%;
    transform: scaleX(${({ width }) => width / 100});
    transform-origin: center left;
    transition: transform 1.5s ease;
    ...
`;
```

`BarGraph`의 애니메이션을 `scaleX` 로 수정했다.

이때 `scaleX` 안에 있는 `width` 는 퍼센트 값이기 때문에 `scaleX` 함수의 인자로 쓰일 수 있도록 1 이하의 실수 값으로 바꿔준다.

이렇게 하면 `width` 가 0일 때 `scaleX` 에 의해 막대(`BarGraph`)의 너비가 0으로 줄어든다.  
 `width` 값이 100이 되면 `scaleX(1)` 이 되므로 `width`가 100%인 상태로 유지될 것이다.

여기서 주의할 점은 단순히 `transform` 에 `scaleX` 값만 설정하면 막대 너비가 비율대로 표시되긴 하나, 왼쪽에 치우치지 않고 **가운데 정렬**이 되어 버린다.  
그 이유는 `scale` 은 기본적으로 기준점이 중앙에 있기 때문에 가운데 정렬이 된 것이다.  
이것을 왼쪽 기준으로 변경하기 위해 `transform-origin` 속성을 `center left` 로 변경한다.

<img width="790" alt="image" src="https://github.com/whateveriiwant/whateveriiwant/assets/80333011/d5054ee5-78e5-4312-bc88-caf6c1b2f7b2">

(기준점이 왼쪽으로 설정되지 않은 `scaleX`)

## 📌 3.7 최적화 전후 비교

### 🌧️ 최적화 전

<img width="747" alt="Screenshot 2023-05-18 at 12 21 26" src="https://github.com/whateveriiwant/whateveriiwant/assets/80333011/c0366f47-13fc-4082-9333-8283da6d775e">

최적화 전 메인 스레드의 렌더링 작업이다.

작업이 렌더링 시간을 초과하고 있으며 작업을 제때 마무리하지 못하는 것을 볼 수 있다.

<img width="946" alt="Screenshot 2023-05-25 at 12 43 32" src="https://github.com/whateveriiwant/whateveriiwant/assets/80333011/a50a1f28-b9ea-4860-b03c-e0d279692c90">

최적화 후의 메인 스레드이다.

확실히 최적화 전보다 여유로워 진 것이 보이며 포함된 작업도 더 적은 것을 볼 수 있다. 레이아웃과 페인트 작업이 생략되었기 때문이다.
